# 設定管理リファクタリングの状況報告と課題分析

## 1. 目的（ゴール）
**「設定管理の中央集権化（Single Source of Truthの確立）」**
各画面（LiveView）や実行エンジン（TapMacro）が個別に `profiles.yaml` をディスクから読み込んでいた現状を改善し、メモリ上で一元管理する `ConfigStore` プロセスを導入することで、以下の実現を目指しました。
- マクロ実行時のディスクI/O排除によるレスポンス向上。
- PC/スマホ全画面での設定変更のリアルタイム同期。
- アプリ起動時の確実な初期設定ファイル生成（プロビジョニング）。

## 2. 実施したアクション
1.  **`ConfigStore` (GenServer) の実装**: ファイルの監視、メモリ保持、PubSubによる変更通知。
2.  **`TapMacro` のリファクタリング**: `ConfigStore` のキャッシュを参照するように変更。
3.  **UI（MacroLive, DashboardLive, SetupLive）の変更**: 購読モデル（PubSub）への移行。
4.  **DI（依存性注入）の試行**: テスト環境用の `_test_store` パラメータ等の導入。

## 3. 失敗の原因分析

### A. テスト環境におけるプロセスの競合
`ConfigStore` を名前付きプロセスとしたため、`ExUnit` での並列実行時に `:already_started` エラーが発生しました。これを避けるために動的な名前を導入した結果、PubSubのトピック管理が複雑化し、テストの安定性が著しく低下しました。

### B. LiveViewのライフサイクルとDIの不整合
テストコードから LiveView へ「どのプロセスを参照するか」を伝える DI の仕組み（クエリパラメータ等）が、Elixirのモジュール名（アトム ↔ 文字列）の変換不備により、実行時エラーや意図しないリダイレクトを多発させました。

### C. 非同期チェーンによるレースコンディション
「ファイル更新 -> 検知 -> 通知 -> UI更新」の連鎖が非同期であるため、同期的なテストコードで状態をアサートするのが困難になり、タイムアウトが多発しました。

### D. アーキテクチャ境界の曖昧化
「設定データの取得」というドメイン要求が、`ConfigStore` という「特定のプロセスの実装詳細（Adapter層）」に強く依存してしまい、テスト時にモジュールを分離できなくなりました。

## 4. 再設計の方針（クリーンな復旧案）

現在の複雑化した同期ロジックを整理し、Behaviorベースの抽象化に移行します。

1.  **Behavior（インターフェース）の定義**:
    - `Axon.App.ConfigProvider` Behavior を定義。
    - `get_config()` と `subscribe()` をインターフェースとして固定。
2.  **実装の分離**:
    - **Production**: `ConfigStore` (GenServer) が Behavior を実装。
    - **Test**: `StaticConfigProvider` (モジュールスタブ) が Behavior を実装。テスト時にプロセスを起動する必要をなくす。
3.  **プロビジョニングの独立**:
    - ファイル生成（初回コピー）をロード処理から完全に分離し、`Application.start` 直後に一度だけ実行する独立した UseCase とします。
4.  **同期モデルの単純化**:
    - UI側は「通知が来たら再取得する」という単純な購読モデルを維持しつつ、DIの対象を「プロセス名」ではなく「Behaviorの実装モジュール」に統一します。

---
作成日: 2025-12-31
ステータス: 計画中（実装停止）
